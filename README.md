# dbex - A High-Performance Key-Value Database

A key-value database built in Rust, designed for learning performance optimizations and database internals. This is a personal project for me to learn Rust, which I have no experience in. The focus is on understanding database internals and I/O optimizations between RAM and SSD. And yes this README was primarily generated by Claude.

## Features

- **Append-only storage**: Key-value pairs stored as raw bytes (`&[u8]`)
- **In-memory index**: `HashMap` for O(1) key lookups
- **Index persistence**: Automatic index serialization to `.index` file using bincode
- **Fast recovery**: Loads index from disk on startup instead of scanning entire database
- **Buffered I/O**: Uses `BufWriter` for optimized write performance
- **Comprehensive benchmarks**: Multiple test categories with different access patterns
- **Type-safe Rust implementation**

## Quick Start

```bash
# Run all tests
cargo test

# Run specific benchmark tests
cargo test bench_tiny        # 1K keys, tests CPU cache behavior
cargo test bench_small       # 100K keys, fits in RAM
cargo test bench_medium      # 1M keys, RAM pressure
cargo test bench_large       # 1M keys with 1KB values (1GB data)
cargo test bench_large_heavy_reads  # 1M keys, 8KB values, 100K reads

# Run tests with output visible
cargo test -- --nocapture

# Build the project
cargo build

# Build in release mode for accurate performance testing
cargo build --release
cargo test --release
```

## Project Structure

```
src/
  lib.rs      # Core DBex storage engine

tests/
  integration_tests.rs  # Correctness tests with automatic cleanup
  bench.rs             # Performance benchmark tests
```

## Architecture

### Storage Engine (`src/lib.rs`)

The `DBex` struct implements an append-only key-value store:

**File Format:**
```
[key_len: 4 bytes][key][value_len: 4 bytes][value]
[key_len: 4 bytes][key][value_len: 4 bytes][value]
...
```
- All lengths are 4-byte big-endian (`u32`)
- Keys and values are raw byte arrays
- New entries are always appended to the end

**In-Memory Index:**
- `HashMap<Vec<u8>, ValueLocation>` maps keys to file positions
- Provides O(1) lookup performance
- Tracks exact offset and length for each value

**Persistence & Recovery:**
- Index is serialized to `.index` file using bincode 2.0
- On startup, loads index from `.index` file (if exists)
- No need to scan entire database file on recovery
- `flush()` ensures both data and index are persisted to disk

**I/O Optimization:**
- Write path: `BufWriter` for buffered writes
- Read path: Direct seeks to specific offsets based on index
- Tracks `write_pos` for next append location

### Testing Structure

**Integration Tests** (`tests/integration_tests.rs`):
- Correctness tests for core functionality
- `TestDb` guard pattern ensures cleanup even on test failure
- Automatically removes both `.db` and `.index` files
- Key tests:
  - `test_index_persistence_and_recovery`: Verifies index saves and loads correctly
  - `test_recovery_with_new_data_after_reopen`: Tests incremental updates across restarts
  - `test_many_small_keys`: 10K entries to test scalability

**Benchmark Tests** (`tests/bench.rs`):
- Performance measurement tests
- Each test creates a fresh database with automatic cleanup
- Benchmark functions:
  - `bench_sequential_writes`: Write throughput and latency
  - `bench_sequential_reads`: Sequential read performance
  - `bench_random_reads`: Uniform random key access
  - `bench_zipfian_reads`: 80/20 hot key distribution (realistic workload)

## Current Status

**Completed** âœ…
- Append-only file format
- In-memory HashMap index
- Index persistence and recovery (bincode serialization)
- CRUD operations (Create/Read only; Update/Delete not implemented)
- Buffered writes with `BufWriter`
- Comprehensive test suite with automatic cleanup
- Benchmarking framework with multiple access patterns

**Known Issues:**
- Some tests failing with "failed to fill whole buffer" error
- Potential index/data sync issue in `flush()` method

**Next Steps:**
- WAL (Write-Ahead Log) for transaction atomicity
- B-Tree indexes for range queries
- Write batching
- Deletion and compaction
- Query optimization

## Dependencies

- **bincode 2.0.1** - Index serialization (uses `Encode`/`Decode` traits)
- **serde 1.0** - Serialization framework (with derive feature)
- **rand 0.9** - Random access patterns in benchmarks

## Notes

- Transaction methods (`start_txn`, `commit_txn`) are stubs - not yet implemented
- Performance testing should use release builds for accurate results
- Both `.db` and `.index` files are created in the working directory
- Focus is on understanding I/O optimization between RAM and SSD
